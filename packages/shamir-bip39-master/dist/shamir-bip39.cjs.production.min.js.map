{"version":3,"file":"shamir-bip39.cjs.production.min.js","sources":["../src/leftPad.ts","../src/hex.ts","../src/tables.ts","../src/constants.ts","../src/lagrange.ts","../src/horner.ts","../src/deriveShare.ts","../src/deriveHex.ts","../src/recoverMnemonic.ts","../src/recoverHex.ts","../src/splitMnemonic.ts","../src/splitHex.ts"],"sourcesContent":["/**\n * Pads a string with the given padString on the left until the specified length is achieved\n * @param str The string to pad\n * @param padString The string to add\n * @param length The desired length of the result\n */\nexport function leftPad(\n  str: string,\n  padString: string,\n  length: number\n): string {\n  while (str.length < length) {\n    str = padString + str;\n  }\n  return str;\n}\n","import { leftPad } from './leftPad';\n\nexport function isHex(hex: string): boolean {\n  return !!hex.match(/^[0-9a-fA-F]+$/);\n}\n\n/**\n * Given a hex string, return a vector of numbers, where\n * each number belongs to GF(256)\n */\nexport function hexToIntVector(hex: string): number[] {\n  /* istanbul ignore if */\n  if (!isHex(hex)) {\n    throw new Error(`Expected a hex string, but got ${hex}`);\n  }\n\n  /**\n   * Any two digit hex number belongs to GF(256), so we will split the given\n   * hex string into an array of two digit hex strings and then convert to\n   * numbers.\n   */\n\n  // If we have an odd number of digits, padd a 0 to the front to preserve the\n  // full number.\n  // Note, this will never occur with a valid BIP39 entropy\n  const paddedSecret = leftPad(hex, '0', hex.length + (hex.length % 2));\n\n  // Split the string into an array of strings with two hex characters each.\n  const splitSecret = paddedSecret.match(/.{1,2}/g) as string[];\n\n  // Convert the hex strings to integers.\n  return splitSecret.map(value => parseInt(value, 16));\n}\n","import { BIT_SIZE, PRIMITIVE_POLYNOMIAL, MAX_SHARES } from './constants';\n\nexport const logs: number[] = [];\nexport const exps: number[] = [];\n\nfor (let i = 0, x = 1; i < BIT_SIZE; ++i) {\n  exps[i] = x;\n  logs[x] = i;\n  x = x << 1;\n  if (x >= BIT_SIZE) {\n    x = x ^ PRIMITIVE_POLYNOMIAL;\n    x = x & MAX_SHARES;\n  }\n}\n","export const PRIMITIVE_POLYNOMIAL = 29;\nexport const BIT_COUNT = 8;\nexport const BIT_SIZE = 2 ** BIT_COUNT;\nexport const MAX_SHARES = BIT_SIZE - 1;\n","import { logs, exps } from './tables';\nimport { MAX_SHARES } from './constants';\n\n/**\n * Evaluate the Lagrange interpolation polynomial at x = `at`\n * using x and y Arrays that are of the same length, with\n * corresponding elements constituting points on the polynomial.\n *\n * Based on https://github.com/grempe/secrets.js/blob/14a4b682a28242b1dbe5506674b5d5f476b78dbf/secrets.js#L385\n */\nexport function lagrange(at: number, x: number[], y: number[]) {\n  let sum = 0;\n  let product;\n\n  for (let i = 0; i < x.length; i++) {\n    if (y[i]) {\n      product = logs[y[i]];\n\n      for (let j = 0; j < x.length; j++) {\n        if (i !== j) {\n          /* istanbul ignore if */\n          if (at === x[j]) {\n            // happens when computing a share that is in the list of shares used to compute it\n            product = -1; // fix for a zero product term, after which the sum should be sum^0 = sum, not sum^1\n            break;\n          }\n          product =\n            (product + logs[at ^ x[j]] - logs[x[i] ^ x[j]] + MAX_SHARES) %\n            MAX_SHARES; // to make sure it's not negative\n        }\n      }\n\n      // though exps[-1] === undefined and undefined ^ anything = anything in\n      // chrome, this behavior may not hold everywhere, so do the check\n      /* istanbul ignore next */\n      sum = product === -1 ? sum : sum ^ exps[product];\n    }\n  }\n\n  return sum;\n}\n","import { MAX_SHARES } from './constants';\nimport { exps, logs } from './tables';\n\n/**\n * Evaluate the given polinomial over GF(256) (with MAX_SHARES = 255)\n *\n * https://github.com/grempe/secrets.js/blob/14a4b682a28242b1dbe5506674b5d5f476b78dbf/secrets.js#L364\n */\nexport function horner(x: number, coeffs: number[]) {\n  let fx = 0;\n\n  for (let i = coeffs.length - 1; i >= 0; --i) {\n    if (fx !== 0) {\n      fx = exps[(logs[x] + logs[fx]) % MAX_SHARES] ^ coeffs[i];\n    } else {\n      fx = coeffs[i];\n    }\n  }\n\n  return fx;\n}\n","import {\n  entropyToMnemonic,\n  mnemonicToEntropy\n} from 'bip39';\nimport { deriveHex } from './deriveHex';\nimport { Shares } from './types';\n\nexport function deriveShare(shares: Shares, at: number): Shares {\n  const hexShares = Object.keys(shares).reduce<Record<string, string>>(\n    (accum, id) => {\n      const hexShare = mnemonicToEntropy(shares[id]);\n\n      accum[id] = hexShare;\n      return accum;\n    },\n    {}\n  );\n  const entropy = deriveHex(hexShares, at);\n  const derivedShare: Record<string, string> = {};\n  derivedShare[at.toString()] = entropyToMnemonic(entropy)\n  return derivedShare;\n}\n","import { hexToIntVector } from './hex';\nimport { lagrange } from './lagrange';\nimport { leftPad } from './leftPad';\n\nexport function deriveHex(shares: Record<string, string>, at: number) {\n  const x: number[] = [];\n  const y: number[][] = [];\n\n  Object.keys(shares).forEach(shareId => {\n    const share = hexToIntVector(shares[shareId]);\n\n    x.push(parseInt(shareId, 10));\n\n    for (let j = 0; j < share.length; j++) {\n      y[j] = y[j] || [];\n      y[j][x.length - 1] = share[j];\n    }\n  });\n\n  return y\n    .map(part => lagrange(at, x, part))\n    .reduce((accum, part) => {\n      const partHex = leftPad(part.toString(16), '0', 2);\n      return accum + partHex;\n    }, '');\n}\n","import { entropyToMnemonic, mnemonicToEntropy } from 'bip39';\nimport { recoverHex } from './recoverHex';\nimport { Shares } from './types';\n\nexport function recoverMnemonic(shares: Shares): string {\n  const hexShares = Object.keys(shares).reduce<Record<string, string>>(\n    (accum, id) => {\n      const hexShare = mnemonicToEntropy(shares[id]);\n\n      accum[id] = hexShare;\n      return accum;\n    },\n    {}\n  );\n  const entropy = recoverHex(hexShares);\n  return entropyToMnemonic(entropy);\n}\n","import { hexToIntVector } from './hex';\nimport { lagrange } from './lagrange';\nimport { leftPad } from './leftPad';\n\n/**\n * Recovers a hex secret from the given shares.\n *\n * Based on https://github.com/grempe/secrets.js/blob/14a4b682a28242b1dbe5506674b5d5f476b78dbf/secrets.js#L549\n */\nexport function recoverHex(shares: Record<string, string>) {\n  const x: number[] = [];\n  const y: number[][] = [];\n\n  // Split each share's hex data into an Array of Integers,\n  // then 'rotate' those arrays where the first element of each row is converted to\n  // its own array, the second element of each to its own Array, and so on for all of the rest.\n  // Essentially zipping all of the shares together.\n  //\n  // e.g.\n  //   [ 193, 186, 29, 150, 5, 120, 44, 46, 49, 59, 6, 1, 102, 98, 177, 196 ]\n  //   [ 53, 105, 139, 49, 187, 240, 91, 92, 98, 118, 12, 2, 204, 196, 127, 149 ]\n  //   [ 146, 211, 249, 167, 209, 136, 118, 114, 83, 77, 10, 3, 170, 166, 206, 81 ]\n  //\n  // becomes:\n  //\n  // [ [ 193, 53, 146 ],\n  //   [ 186, 105, 211 ],\n  //   [ 29, 139, 249 ],\n  //   [ 150, 49, 167 ],\n  //   [ 5, 187, 209 ],\n  //   [ 120, 240, 136 ],\n  //   [ 44, 91, 118 ],\n  //   [ 46, 92, 114 ],\n  //   [ 49, 98, 83 ],\n  //   [ 59, 118, 77 ],\n  //   [ 6, 12, 10 ],\n  //   [ 1, 2, 3 ],\n  //   [ 102, 204, 170 ],\n  //   [ 98, 196, 166 ],\n  //   [ 177, 127, 206 ],\n  //   [ 196, 149, 81 ] ]\n  //\n  Object.keys(shares).forEach(shareId => {\n    const share = hexToIntVector(shares[shareId]);\n    x.push(parseInt(shareId, 10));\n\n    for (let j = 0; j < share.length; j++) {\n      y[j] = y[j] || [];\n      y[j][x.length - 1] = share[j];\n    }\n  });\n\n  return y\n    .map(part => lagrange(0, x, part))\n    .reduce((accum, part) => {\n      const partHex = leftPad(part.toString(16), '0', 2);\n      return accum + partHex;\n    }, '');\n}\n","import { entropyToMnemonic, mnemonicToEntropy } from 'bip39';\nimport { splitHex } from './splitHex';\nimport { Shares } from './types';\n\nexport function splitMnemonic(\n  mnemonic: string,\n  numShares: number,\n  threshold: number\n): Shares {\n  const entropy = mnemonicToEntropy(mnemonic);\n  const hexShares = splitHex(entropy, numShares, threshold);\n\n  return Object.keys(hexShares).reduce<Shares>((accum, id) => {\n    const mnemonicShare = entropyToMnemonic(hexShares[id]);\n\n    accum[id] = mnemonicShare;\n    return accum;\n  }, {});\n}\n","import { horner } from './horner';\nimport randomBytes from 'randombytes';\nimport { hexToIntVector } from './hex';\nimport { leftPad } from './leftPad';\n\n/**\n * Split a hex secrety into numShares, requiring threshold shares to recover.\n *\n * Note: No input validation at this point.\n * Based on https://github.com/grempe/secrets.js/blob/14a4b682a28242b1dbe5506674b5d5f476b78dbf/secrets.js#L901\n */\nexport function splitHex(secret: string, numShares: number, threshold: number) {\n  return hexToIntVector(secret)\n    .map(s => {\n      const randomValues = Array(threshold - 1)\n        .fill(0)\n        .map(() => randomBytes(1))\n        .map(buf => buf.toString('hex'))\n        .map(v => parseInt(v, 16));\n\n      const coeffs = [s].concat(randomValues);\n\n      return Array(numShares)\n        .fill(0)\n        .map((_, i) => {\n          const x = i + 1;\n          return {\n            x,\n            y: horner(x, coeffs),\n          };\n        });\n    })\n    .map(current =>\n      current.map(share => {\n        const hexY = leftPad(share.y.toString(16), '0', 2);\n        return { x: share.x.toString(), y: hexY };\n      })\n    )\n    .reduce<Record<string, string>>((accum, current) => {\n      current.forEach(share => {\n        if (!accum[share.x]) {\n          accum[share.x] = share.y;\n        } else {\n          accum[share.x] += share.y;\n        }\n      });\n      return accum;\n    }, {});\n}\n"],"names":["leftPad","str","padString","length","hexToIntVector","hex","match","isHex","Error","map","value","parseInt","BIT_SIZE","Math","pow","MAX_SHARES","logs","exps","i","x","lagrange","at","y","product","sum","j","horner","coeffs","fx","shares","entropy","Object","keys","forEach","shareId","share","push","part","reduce","accum","toString","deriveHex","id","hexShare","mnemonicToEntropy","derivedShare","entropyToMnemonic","recoverHex","mnemonic","numShares","threshold","hexShares","secret","s","randomValues","Array","fill","randomBytes","buf","v","concat","_","current","hexY","splitHex","mnemonicShare"],"mappings":"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"}